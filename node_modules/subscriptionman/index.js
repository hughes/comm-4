var Backbone = require('backbone');
var _ = require('underscore');

// defaults attribute inheritance, and automatic super.initialize calls
(function () {
    function extend4000 () {
        var args = Array.prototype.slice.call(arguments),
        child = this;

        var initf = [];
        var defaults = {};
        if (child.prototype.defaults) {
            defaults = _.clone(child.prototype.defaults);
        }

        _.each(args, function (superc) {
            // did I receive a dictionary or an object/backbone model?
            if (superc.prototype) { superc = superc.prototype; }

            // inherit defaults
            if (superc.defaults) {
                defaults = _.extend(defaults,superc.defaults);
            }

            // build a list of initialize functions if you find more then one
            if (superc.initialize) {
                (initf.length) || initf.push(child.prototype.initialize);
                initf.push(superc.initialize);
            }

            child = child.extend(superc);
        });

        // construct a combined init function
        if (initf.length) {
            child = child.extend({ initialize : function(attributes,options) {
                var self = this;
                _.map(initf,function(initf) { initf.call(self,attributes,options); });
            }});
        }
        child.prototype.defaults = defaults;
        return child;
    }

    Backbone.Model.extend4000 =
    Backbone.Collection.extend4000 =
    Backbone.Router.extendEach =
    Backbone.View.extend4000 = extend4000;

    function triggerOnce(event,f) {
        var self = this;
        this.bind(event,function() {
            self.unbind(event,f);
            f.apply(this,toArray(arguments));
        });
    }

    Backbone.Model.triggerOnce = triggerOnce;

})();


// simple object that matches json blobs and executes callbacks
// maybe I should upgrade this to use json schemas as patterns
var SubscriptionMan = Backbone.Model.extend({ 
    initialize: function() {
        this.subscriptions = [];
    },

    subscribe: function(msg,f,name) { 
        if (!name) { name = function() { f() }; }
        this.subscriptions.push({pattern: msg, f: f, name: name});
        return name;
    },
    
    unsubscribe: function(name) { 
        this.subscriptions = _.filter(this.subscriptions, function(sub) { return ((sub.name != name) && (sub.f != name)); });
    },

    oneshot: function(msg,f) {
        var self = this;
        function ff() {
            self.unsubscribe(ff); f.apply(this,attributes);
        }
        this.subscribe(msg, ff,ff );
        return function() { self.unsubscribe(ff); };
    },

    _matches: function(msg) {
        function checkmatch(msg,pattern) {
	        for (var property in pattern) {
                if ( property == "*" ) { return true; }
	            if (msg[property] == undefined) { return false; }
	            if (pattern[property] != true) { if (msg[property] != pattern[property]) { return false; } }
	        }
	        return true;
        }

        var res = [];
        
        this.subscriptions.forEach(function(matcher) {
	        var pattern = matcher.pattern;
	        if (checkmatch(msg,pattern)) { res.push (matcher.f);  }
        });
        return res;
    },

    event: function(msg) { 	
        return this._matches(msg).forEach( function(f) { f(msg); } );
    }
});

exports.SubscriptionMan = SubscriptionMan

